---
layout: post
title: 牛客第一场多校
category: blog
description: 真jr难,还被学弟锤爆了.
---
## A.Monotonic Matrix
本题其实是求,两条不相交,可重和的路径的数量.
同时,起点均为$(n,0)$,终点均为$(0,m)$.
我们可以选择平移01这条路径$-\>$起点$(n-1, -1)$,终点$(-1, m-1)$.
这就变成了求两条严格不相交路径的数量,然后套用一个神奇怪的定理:
$Lindström–Gessel–Viennot lemma$
首先得到$[a_{1} = (n, 0), a_{2} = (n-1, -1), b_{1} = (0, m), b_{2} = (-1, m-1)]$
然后得到行列式$[e(a1, b1), e(a1, b2); e(a2, b1), e(a2, b2)]$
&e(u,v)&为 &u& 到 &v& 边数之和,显然此题可以用dp来快速求得:
$dp[i][j] = dp[i-1][j] + dp[i][j-1]$
$e(u,v) = dp[u.x + v.x][u.y + v.y]$
此题得解
```
/* ***********************************************
Author        :JiangYu
Created Time  :2018年07月19日 星期四 20时09分37秒
File Name     :a.cpp
************************************************ */
 
#include <bits/stdc++.h>
 
using namespace std;
const int N = 1024;
const int MOD = 1e9 + 7;
void update(int &x, int a) {
    x += a;
    x %= MOD;
}
int sqr(int x) {
    return 1ll * x * x % MOD;
}
int dp[N][N];
int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    dp[0][0] = 1;
    for(int i = 0; i < N; ++i) {
        for(int j = 0; j < N; ++j) {
            if(i) update(dp[i][j], dp[i-1][j]);
            if(j) update(dp[i][j], dp[i][j-1]);
        }
    }
    int n, m;
    while(scanf("%d%d", &n, &m) != EOF) {
        printf("%d\n",int( (sqr(dp[n][m]) + MOD - 1ll * dp[n-1][m+1] * dp[n+1][m-1] % MOD ) % MOD ));
    }
    return 0;
}
```
