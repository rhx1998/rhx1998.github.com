---
layout: post
title: 牛客第一场多校
category: blog
description: 真jr难,还被学弟锤爆了.
---
## A.Monotonic Matrix
本题其实是求,两条不相交,可重和的路径的数量.
同时,起点均为$(n,0)$,终点均为$(0,m)$.
我们可以选择平移01这条路径$-\>$起点$(n-1, -1)$,终点$(-1, m-1)$.
这就变成了求两条严格不相交路径的数量,然后套用一个神奇怪的定理:
$Lindström–Gessel–Viennot lemma$
首先得到$[a_{1} = (n, 0), a_{2} = (n-1, -1), b_{1} = (0, m), b_{2} = (-1, m-1)]$
然后得到行列式$[e(a1, b1), e(a1, b2); e(a2, b1), e(a2, b2)]$
$e(u,v)$为 $u$ 到 $v$ 边数之和,显然此题可以用dp来快速求得:
$dp[i][j] = dp[i-1][j] + dp[i][j-1]$
$e(u,v) = dp[u.x + v.x][u.y + v.y]$
此题得解
```
/* ***********************************************
Author        :JiangYu
Created Time  :2018年07月19日 星期四 20时09分37秒
File Name     :a.cpp
************************************************ */
 
#include <bits/stdc++.h>
 
using namespace std;
const int N = 1024;
const int MOD = 1e9 + 7;
void update(int &x, int a) {
    x += a;
    x %= MOD;
}
int sqr(int x) {
    return 1ll * x * x % MOD;
}
int dp[N][N];
int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    dp[0][0] = 1;
    for(int i = 0; i < N; ++i) {
        for(int j = 0; j < N; ++j) {
            if(i) update(dp[i][j], dp[i-1][j]);
            if(j) update(dp[i][j], dp[i][j-1]);
        }
    }
    int n, m;
    while(scanf("%d%d", &n, &m) != EOF) {
        printf("%d\n",int( (sqr(dp[n][m]) + MOD - 1ll * dp[n-1][m+1] * dp[n+1][m-1] % MOD ) % MOD ));
    }
    return 0;
}
```
## B.Symmetric Matrix
此题感谢 美食不可负064 的题解
参考: [B题 解题思路](https://www.nowcoder.com/acm/contest/139/B)

首先,这道题的表述方法以前出过类似的.将图伪装成一个矩阵,所以可以一眼看出来.
这是一个每个点度数为$2$,没有自环,允许有重边的无向图.
每个点度数均为$2$,画一下可以发现,每一个点属于且仅属于一个环.
所以这是一个有很多个简单环的图.
定义$dp[n]$表示n个点构成的合法图的方案数.
考虑从前面的$n-1$个球中取k个球与新球组成一个环$: C_{n-1, k} * (n-1-k)!$.
由于对称性要除以$2$.
同时,只取一个球时不用考虑对称性$: (n-1)*dp[n-2]$.
最后得$: dp[n] = (n-1)dp[n-2] + sigma(x:2->n-3)((n-1)!/(2*x!)dp[x])$
巧妙的化简为$: dp[n] = (n-1)dp[n-2] + (n-1)dp[n-1] - (n-1)(n-3)dp[n-3]/2$
```
/* ***********************************************
Author        :JiangYu
Created Time  :2018年07月20日 星期五 01时09分59秒
File Name     :b.cpp
************************************************ */

#include <bits/stdc++.h>

using namespace std;
int mod;
void update(int &x, int a) {
	x += a;
	x %= mod;
}
const int N = 1e5 + 10;
int dp[N];
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
    int n;
	while(scanf("%d%d", &n, &mod) != EOF) {
		memset(dp, 0, sizeof dp);
		dp[0] = 1;
		int sum = 0;
		for(int i = 1; i <= n; ++i) {
			dp[i] = dp[i-2] * (i - 1ll) % mod;
			sum = sum * (i - 1ll) % mod;
			if(i >= 3) {
				update(sum, (i - 1ll) * (i - 2) / 2 % mod * dp[i -3] % mod);
			}
			update(dp[i], sum);
		}
		printf("%d\n", dp[n]);
	}
    return 0;
}

```
## D.Two Graphs
求G2的子图里有多少个与G1同构,但是有去掉自同构的数量.
我不会算自同构,所以直接$n!$枚举了所有的同构方案,然后用set存下去重.
```
/* ***********************************************
Author        :JiangYu
Created Time  :2018年07月19日 星期四 14时19分52秒
File Name     :d.cpp
************************************************ */

#include <bits/stdc++.h>

using namespace std;
typedef pair<int, int> P;
const int N = 10;
int n, m1, m2;
int pre[N];
int x1[100], Y1[100], x2[100], y2[100];
bool vis[20][20];
struct Node{
	vector<int> V;
	vector<P> E;
	bool operator<(const Node &o) const {
		for(int i = 0; i < (int)V.size(); ++i)
			if(V[i] != o.V[i]) return V[i] < o.V[i];
		for(int i = 0; i < (int)E.size(); ++i)
			if(E[i] != o.E[i]) return E[i] < o.E[i];
		return 0;
	}
};
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
	while(scanf("%d%d%d", &n, &m1, &m2) != EOF) {
		memset(x1, 0, sizeof x1);
		memset(x2, 0, sizeof x2);
		memset(Y1, 0, sizeof Y1);
		memset(y2, 0, sizeof y2);
		memset(vis, 0, sizeof vis);
		//cout << n << " " << m1<< " " << m2<< endl;
		for(int i = 1; i <= n; ++i)
			pre[i] = i;
		for(int i = 1; i <= m1; ++i) {
			scanf("%d%d", &x1[i], &Y1[i]);
		}
		for(int i = 1; i <= m2; ++i) {
			scanf("%d%d", &x2[i], &y2[i]);
			vis[x2[i]][y2[i]] = vis[y2[i]][x2[i]] = 1;
		}
		set<Node>S;
		do{
			bool flag = 0;
			for(int i = 1; i <= m1; ++i) {
				int u = pre[x1[i]], v =pre[Y1[i]];
				//cout << u<< " " << v<< endl;
				if(vis[u][v] == 0) {
					flag  = 1;
					break;
				}
			}
			if(flag == 0) {
				vector<int> V;
				for(int i = 1; i<= n; ++i) {
					V.push_back(pre[i]);
				}
				sort(V.begin(), V.end());
				vector<P> E;
				for(int i = 1; i<= m1; ++i) {
					P p(pre[x1[i]], pre[Y1[i]]);
					if(p.first > p.second) swap(p.first, p.second);
					E.push_back(p);
				}
				sort(E.begin(), E.end());
				S.insert({V,E});
			}
			else continue;
		}while(next_permutation(pre+1, pre+1+n));
		printf("%d\n", S.size());
	}
    return 0;
}
```

## J.Different Integers
裸莫队会被卡常,但是你多交几次可能就过了.
这种玄妙的做法就不贴代码了=.=
正解是用一个$last[x]$记录$x$元素最后一个位置,$first[x]$记录$x$元素第一个位置.
离线处理,把r从小到大排序处理,计算没出现的数字个数. $BIT$维护
```
/* ***********************************************
Author        :JiangYu
Created Time  :2018年07月19日 星期四 23时49分50秒
File Name     :j.cpp
************************************************ */
#include <bits/stdc++.h>
const int N = 1e5 + 10;
using namespace std;
int a[N], first[N], last[N];
struct Query{
	int l, r, id;
	Query(){}
	bool operator < (const Query &o) {
		return r < o.r;
	}
}Q[N];
int ans[N], bit[N];
int lowbit(int k) {
	return k & -k;
}
void add(int x, int y) {
	while(x > 0) {
		bit[x] += y;
		x -= lowbit(x);
	}
}
int sum(int x) {
	int res = 0;
	while(x < N) {
		res += bit[x];
		x += lowbit(x);
	}
	return res;
}
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
    int n, q;
	while(scanf("%d%d", &n, &q) != EOF) {
		memset(last, 0, sizeof last);
		memset(first, 0, sizeof first);
		memset(bit, 0, sizeof bit);
		int tot = 0;
		for(int i = 1; i <= n; ++i) {
			scanf("%d", &a[i]);
			last[a[i]] = i;
			if(first[a[i]] == 0)
				tot++, first[a[i]] = i;
		}
		for(int i = 1; i <= q; ++i) {
			int l, r;
			scanf("%d%d", &l, &r);
			Q[i].l = l, Q[i].r = r;
			Q[i].id = i;
		}
		sort(Q+1, Q+1+q);
		for(int i = 1, k = 1; i <= n; ++i) {
			while(k <= q && Q[k].r == i) {
				ans[Q[k].id] = tot;
				ans[Q[k].id] -= sum(Q[k].l);
				k++;
			}
			if(last[a[i]] == i) {
				add(first[a[i]] - 1, 1);
			}
		}
		for(int i = 1; i <= q; ++i) 
			printf("%d\n", ans[i]);
	}
    return 0;
}

```


