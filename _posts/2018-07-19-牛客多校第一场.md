---
layout: post
title: 牛客第一场多校
category: blog
description: 真jr难,还被学弟锤爆了.
---
## A.Monotonic Matrix
本题其实是求,两条不相交,可重和的路径的数量.
同时,起点均为$(n,0)$,终点均为$(0,m)$.
我们可以选择平移01这条路径$-\>$起点$(n-1, -1)$,终点$(-1, m-1)$.
这就变成了求两条严格不相交路径的数量,然后套用一个神奇怪的定理:
$Lindström–Gessel–Viennot lemma$
同时可发现答案为 $(C_{n+m,n})^2 - C_{n+m, m-1}*C_{n+m, n-1}$.
```
//第一版
/* ***********************************************
Author        :JiangYu
Created Time  :2018年07月19日 星期四 20时09分37秒
File Name     :a.cpp
************************************************ */
 
#include <bits/stdc++.h>
 
using namespace std;
const int N = 1024;
const int MOD = 1e9 + 7;
void update(int &x, int a) {
    x += a;
    x %= MOD;
}
int sqr(int x) {
    return 1ll * x * x % MOD;
}
int dp[N][N];
int main()
{
    //freopen("in.txt","r",stdin);
    //freopen("out.txt","w",stdout);
    dp[0][0] = 1;
    for(int i = 0; i < N; ++i) {
        for(int j = 0; j < N; ++j) {
            if(i) update(dp[i][j], dp[i-1][j]);
            if(j) update(dp[i][j], dp[i][j-1]);
        }
    }
    int n, m;
    while(scanf("%d%d", &n, &m) != EOF) {
        printf("%d\n",int( (sqr(dp[n][m]) + MOD - 1ll * dp[n-1][m+1] * dp[n+1][m-1] % MOD ) % MOD ));
    }
    return 0;
}
```

```
//第二版
/* ***********************************************
Author        :JiangYu
Created Time  :2018年07月19日 星期四 20时09分37秒
File Name     :a.cpp
************************************************ */

#include <bits/stdc++.h>

using namespace std;
const int N = 2024;
const int MOD = 1e9 + 7;
int sqr(int x) {
	return 1ll * x * x % MOD;
}
int dp[N][N];
void init() {
    for(int i = 0; i < N; ++i)
        dp[i][0] = 1;
    for(int i = 1; i < N; ++i) {
        for(int j = 1; j < N; ++j) {
            dp[i][j] = (dp[i-1][j] + dp[i-1][j-1]) % MOD;
        }
    }
}
int main()
{
	//freopen("in.txt","r",stdin);
	//freopen("out.txt","w",stdout);
    init();
	int n, m;
	while(scanf("%d%d", &n, &m) != EOF) {
		printf("%d\n",int( (sqr(dp[n+m][n]) + MOD - 1ll * dp[n+m][m-1] * dp[n+m][n-1] % MOD ) % MOD ));
	}
    return 0;
}
```

