---
layout: post
title: 暑假前第一次专题训练解题报告
category: blog
description: 解题报告1
---

### A. 双剑合并

#### 题意

两组数据，在两组数据中各选出一个元素，使其异或的值最大。

#### 分析


思路1：
暴力搜索，两两异或。
错误：
因为 n，m $\in[1,1e6]$，而复杂度为 $ O $$（$nm$）$，很明显会TLE，放弃。

思路2：
考虑到两个长度相同，但不相等的数的大小，必然由从前往后的第一个不同的数字决定，例如$1234567$和$1234367$在第五位时，就已经通过 5 和 3 比较出了大小，不论之后的数字是什么，都无法影响其结果。

而两个数在二进制下的某一位的异或是不会造成进位或者退位的，即这一位数显然只会受到本位的影响。同时可以将所有$int$范围内的数字转化为长度相同的32位二进制数。
    
我们可以将第一组数据的每一个元素，按照其二进制的构成来建立一棵trie树，然后枚举第二组数据的每一个元素，从高位到低位的在trie树中选择能使其异或值最大的那一条分支。这样复杂度就变成了 $ O （n）$，1500 ms 内轻松解决。

#### 思考

技巧:
如果不知道该开多大的数组来储存trie树，可以选择使用结构体，不断的 $new$ 出新的空间，然后用指针来存放。

-----


### B.单词替换

####  题意  

给出一个仅包含小写字母的字符串$S$，和单词$A$,$B$。把$S$中所有出现过的$A$替换为$B$。

#### 分析

思路:
裸的$kmp$,简单构造一下就好了。

#### 思考

坑点：
这个坑不是我发现的，也没有坑到我。是我和lyh交流时候他告诉我的，将$S$中的$A$替换为$B$后，不需要对新生成的字符串进行搜索替换。不然的话,如果是下面这组数据，程序就会陷入死循环。
<pre><code>S:abc
A:ab
B:abb
</code></pre>

-----

### C.01的时间

#### 题意

给你一个数字$N，$找出其仅由$0$和$1$构成的倍数中最小的那一个。

#### 分析

思路1:
使用暴力解出最小的那一个数。
错误：
数据可能会非常大，有$2、30$位。显然在规定时间内无法解出。

思路2：
考虑这个数字只由0、1构成， 可以使用广搜来解决。从第一位开始，当前数字对$N$取余 $ = r$,  若 $r \neq$  0,则将余数 $r \times 10$，然后分别加上 0 或 1 从而形成新的状态, 同时在新状态中记录其前驱 $pre$ 用来最后输出整个数字。若 $ r = 0 $,则已经找到合法的解，跳出循环。

#### 思考

技巧：
使用一个 $bool$ 型数组 $used, used[i]$ 表示余数 $r = i$ 的状态是否已经搜索过了。因为我们是逐步往后添加数字，则如果多次出现余数 $r = i$的状态，显然在第一次出现时解是最优的。因为之后出现$r = i$时，数字的位数显然比一开始出现的时候要大，都是差解。所以当$r = i$已经出现过一次之后，若再次出现这个状态，均可以舍弃不要。

------

### D.Goozy的游戏时间

#### 题意
有一个由$N\times N$个小正方形组成的大正方形，每个小正方形被均匀的切割成了上下左右四个三角形部分，每个部分写着 0 ~ 9 之间的数字，通过将小正方形平移重新构成一个新的大正方形。要求使得大正方形中每个小正方形相邻边上的三角形上的数字都相同。 

例如坐标为$(1,2)$的小正方形下面的三角形要和坐标为$（2,2）$的小正方形上面的三角形数字相同。

#### 分析

思路：
这种奇奇怪怪的题目，我只能想到暴搜 $+$ 剪枝了。通过将使用过了的小正方形标记，一边搜索一边判断，只对合法的状态进一步往下搜索。但是还有吧一个诡异的玄学剪枝，在思考中进行说明。

#### 思考

坑点： 
直接搜索肯定会T，正解的搜法不知道。在网上找到了一个看似有理的玄学剪枝。基于搜索次数来剪枝。当搜索一定次数后还未搜索到正解，直接视为正解不存在。我在此题中使用的是 $5e5$ ，也就是说，如果搜到了 $5e5$ 步还未找到结果，就直接舍去对于这个状态之后的搜索，将其视为错解。

但这方法显然是不科学的，所以一定要慎用！

技巧:
就是坑点中提到的，在某些不论怎么调都是T的题里，可以考虑尝试通过基于搜索次数，甚至是基于程序运行时间来进行剪枝。

-----

###E. RunningPhoton's Nightmare

#### 题意

在一个$N\times N$ 的迷宫里，在规定的时间内从 $S$ 跑到 $E$ 。迷宫中有：

* $. $  空地 ： 可以走的地方
* $W$ 墙 ： 不可以走的地方
* $R$ 时间重置装置 ： 将时间重置

可以通过不断走到$R$将时间重置，让自己能顺利到达出口。

#### 分析

思路：
就是普通的广搜，在原来$bool$  $used[i][j]$,的基础上，改成 $int$ $used[i][j]$从原来的储存是否走过$（i，j）$进化成走到(i,j)还剩多少时间，如果重复到达一个点，剩下的时间比之前到的时候多就保存，否则舍弃。

#### 思考
坑点：
要注意，如果某一步走下去后，时间为 0 ，则这一步不合法。


----

###F. 表达式
#### 题意
从1开始，可以对其进行以下操作：

* 加上已经得到的数中 $\in[1,本身]$的任意一个数，得到一个新数。
* 减去已经得到的数中 $\in[1,本身]$的任意一个数，得到一个新数。

求得到n的最少操作步数。

#### 分析
思路：

将题意提炼到这个地步就很容易想到这是一道广搜题。先考虑暴力搜，因为$\ n_{max}\  =\  1000\ \ \ \  T_{max} \ = \ 1000 $,显然会T。然后就想着该剪枝了。

首先，有一个很容易想到的剪枝，使用$IDA^*$,不断寻找可能的最小步骤。

其次，可以利用$A^*$的思想，如果当前状态不断加上自己，在当前$IDA^*$假设出来的最小步骤内无法达到$n$，则显然不成立，可以丢掉。
#### 思考

一遍过，没啥问题。

----
###G. 神舟的宝藏

#### 题意

给你一个十进制整数$\ N$，$M\ $个 $\ C\ $进制整数.要求用这$\ M\ $个$\ C\ $进制数构成成一个500位以内的$N$最小整数倍数，每个数字可重复利用，也可以不用。

#### 分析

思路：
就是$\ C.$**01的时间** 的变式，一样的做法。

#### 思考
坑点1：
这道题的坑点又不是我发现的，又没坑到我。又是我和lyh交流时发现的。因为 $N<5000$，如果想将所有过程记录下来显然是不可能的，但是可以利用01的时间里的那个性质，如果一个余数已经出现过了，之后再次出现这个余数都是差解，是不用考虑的。这样需要保存的状态就很少了。

坑点2：
如果$\ n\ $是$\ 0\ $,特判一下$M$中有没有$0$即可。

-----
###H. DNA序列
#### 题意
给你$\ (1 \leq N \leq 8)\ $个长度在$1$和$5$之间的仅由$A/C/G/T$构成的字符串。要求找到一个尽可能短的序列，能够包含所有给定的字符串。

#### 分析

思路:
$IDA^*$搜索一发，利用当前预测的长度来剪枝。

#### 思考
坑点:
如果有$\ T\ =\ 500\ $组以下数据，会要跑很久
<pre><code>
    AAAAA
    CCCCC
    GGGGG
    TTTTT
</code></pre>
但是依旧过了，所以数据一定很水。

----
###I. 小冰和小娜
#### 题意

在一个$n\times m$ 的地图上，从 $S$ 跑到 $T$ 。# 表示障碍物，一开始在起点面朝北方，每次可以选择向左转、向右转、向前走一步。任意一个选择耗时1s，同时要求前进**5的倍数步**到达终点。最终输出最短的耗时，不能达到输出-1.

#### 分析
思路：
就是普通的广搜，不过要做一点变形。
第一，将$ bool\ used[i][j] $ 表示$（i,j）$是否走过改成 $bool\ used[i][j][re][way]$ 表示$（i,j） $在步数$\%5$为re时，面朝 $way$方向是否走过。
第二，将普通广搜的朝四个方向前进改成向左转、向右转、向正前方前进。

#### 思考
坑点：
这题是我自己写挂了，我把西方向和南反向写反了，导致$\ wa\ $了一发。

----
###J. TooEasy Or TooDifficult

#### 题意

给你一个长度为$k$的字符串 $S$ ，每个字符串有一数值 $ P $，表示以该字符为中心的回文串的长度。
同时定义

*  $JD \ \ \ \ =\ \  (MZ ^{k^3}$)$ \%$ $(MZ/3 \times 5 + 1) + MZ \times 4/5$ 

*  $MZ\ \ \  = \ \ MAX\{P_1 ...P_k\}$

* $FJD \ = \ \ MAX\{SC_{ij}|0\leq i \leq j \leq k \}$

* $SCij=P_{i}\ xor\ P_{i+1}\ xor\ \ldots \ xor\ P_j$

然后比较$JD$和$FJD$的大小
#### 分析

思路：
先用$Manacher$,求出P；然后根据异或的性质，我们可以使用类似于前缀和的前缀异或。从而将问题转移为在$k$个前缀异或里求出两个前缀异或，使其异或值最大。这就与$A.$**双剑合并**是一样的了。
#### 思考
坑点：
要注意在求 $JD$ 时，快速幂里面 $MOD$的写法，我$WA$了一次就是那里写挂了，虽然是很不应该的错误，但依旧错了。
坑点： 
    在构建$\ trie\ $树时，要先插入一个$\ 0\ $，不让无法得到包括$a[1]$的前缀异或。不过这道题的数据没有卡这一点，所以我幸运的过了。

----

###K. 奶牛合影
#### 题意
 $N$头奶牛排成一圈，每个奶牛有一个编号，要求选择从一头奶牛开始，顺时针循环一圈，其编号顺次组成的序列字典序最小。

#### 分析

思路：
最小表示法的裸题。

#### 思考

技巧：
套板子

----

###L. 奶牛序列

#### 题意
一个长度为$\ 2\leq n\leq 500000\ $的字符串$\ S\ $.$\ \ T_i$表示从第$\ i\ $的字符开始的后缀。求：
$\ \ \ \sum len(T_i)+len(T_j) - 2\times lcp(T_i,T_j)$
$^{1 \leq i \leq j \leq n}$
其中，$len(a)$表示字符串$a$的长度，$lcp(a,b)$表示字符串$a$和字符串$b$的最长公共前缀
#### 分析
思路:
首先，$\{len(T_i)+len(T_j)| 1 \leq i \leq j \leq n \}$可以提取出来另外计算。
其次,$lcp(T_i,T_j)$可以使用后缀数组衍生出来的高度数组快速计算。即为$lcp(i,j) = MIN\{h[k]\ |\ i \leq k \leq j \}$.那么就变成了求所有的$（i，j）$对之中最小的$h[k]$的和值。我们可以考虑，一个$h[k]$对于整体的贡献取决于他左右分别所能到达的距离的积。这个距离肯定不能用暴力求，在学长的指导下，想到了单调栈。在$O(n)$的复杂度下，可以快速得出一边所能达到的最远距离。

#### 思考
坑点：
我挂了很久的原因在于对于两边均取了小于等于的状况时停止。但是这种情况对于以下数据显然是不成立的：
<pre><code>
    1 1
</code></pre>
如果均取小于等于，就只能得到两组结果
<pre><code>
    1 
    1
</code></pre>
但实际上有三组结果
<pre><code>
    1 
    1
    11
</code></pre>
所以要在左边取小于，右边取小于等于。



