---
layout: post
title: 重庆大学第十五届校赛暨西南邀请赛决赛
category: blog
description: 菜鸡就该多补题
---
## A.简单题
签到题，懒得写

## B. Costly Graphs

## C. The King's Problem

## D. 国家集训队论文集
统计有多少个相同的数字
签到题，代码懒得写

## E. OneDoubleC的小卡片
最小的放中间，大的放两边。最大的放中间，小的放两边。两种方式取最大。
```
/*
 * Author:  JiangYu
 * Created Time:  2018/5/28 23:34:35
 * File Name: E.cpp
 */
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
#define PB push_back
#define X first
#define Y second
#define FI first
#define SE second
#define inf 0x3f3f3f3f
#define FOR(i,a,b) for(int i = a; i <= b; ++i)
#define FORD(i,a,b) for(int i = b; i >= a; --i)
#define ALL(x) x.begin(),x.end()
#define REP(i,a) for(int i = 0; i < a; ++i)
#define DEP(i,a) for(int i = a-1; i >= 0; --i)
#define CLR(a) memset(a, 0, sizeof a)
int a[1024];
int b[10000];
int n;

bool cmp(const int o, const int  t) {
    return o > t;
}
int minsort() {
    sort(a+1, a+1+n, cmp);
    memset(b, 0, sizeof b);
    int front = 1, flag = n-1;
    int l = 5000, r = 5000;
    b[5000] = a[n];
    while(front <= flag) {
        if(front > flag) break;
        b[--l] = a[front++];
        if(front > flag) break;
        b[++r] = a[front++];
        if(front > flag) break;
        b[--l] = a[flag--];
        if(front > flag) break;
        b[++r] = a[flag--];
    }
    int ans = 0;
    for(int i = l; i < r; ++i) {
        ans += abs(b[i] - b[i+1]);
    }
    return ans;
    
}
int maxsort() {
    sort(a+1, a+1+n);
    memset(b, 0, sizeof b);
    int front = 1, flag = n-1;
    int l = 5000, r = 5000;
    b[5000] = a[n];
    while(front <= flag) {
        if(front > flag) break;
        b[--l] = a[front++];
        if(front > flag) break;
        b[++r] = a[front++];
        if(front > flag) break;
        b[--l] = a[flag--];
        if(front > flag) break;
        b[++r] = a[flag--];
    }
    int ans = 0;
    for(int i = l; i < r; ++i) {
        ans += abs(b[i] - b[i+1]);
    }
    return ans;
}
int main() {
    int t;
    scanf("%d", &t);
    while(t--) {
        scanf("%d", &n);
        for(int i = 1; i <= n; ++i) scanf("%d", &a[i]);
        cout << max(minsort(), maxsort())<<endl;
    }
    return 0;
}
```

## F. 任香香公主遇上女装群群主
垃圾题面，看了就不想写
可以发现，从左上角走到右下角至少要$n+m-2$步，也就是说，我们从左上角出发，只能向下或者向右的路径上。
至多只能执行一次向上或者向左的走法。
我们先预处理出，从左上到右下只能向下向右走 与 从右下到左上只能向上向左走的两种情况。
画图发现想要将两种情况拼接起来，在不重复选的前提下，只有如下4种情况：
![](https://imgchr.com/i/C4ySdH)
![](/images/F.png)
```
/*
 * Author:  JiangYu
 * Created Time:  2018/5/28 23:58:34
 * File Name: F.cpp
 */
#include <bits/stdc++.h>
using namespace std;
#define ll long long
#define MP make_pair
#define PB push_back
#define X first
#define Y second
#define FI first
#define SE second
#define inf 0x3f3f3f3f
#define FOR(i,a,b) for(int i = a; i <= b; ++i)
#define FORD(i,a,b) for(int i = b; i >= a; --i)
#define ALL(x) x.begin(),x.end()
#define REP(i,a) for(int i = 0; i < a; ++i)
#define DEP(i,a) for(int i = a-1; i >= 0; --i)
#define CLR(a) memset(a, 0, sizeof a)
const int N = 1024;
int n, m;
int a[N][N], f[N][N], g[N][N];
int main() {
    int t;
    scanf("%d", &t);
    while(t--) {
        scanf("%d%d", &n, &m);

        for(int i = 1; i <= n; ++i)
            for(int j = 1; j <= m; ++j) 
                scanf("%d", &a[i][j]);
        f[1][1] = a[1][1];
        for(int i = 2; i <= n; ++i)
            f[i][1] = f[i-1][1] + a[i][1];
        for(int i = 2; i <= m; ++i)
            f[1][i] = f[1][i-1] + a[1][i];
        for(int i = 2; i <= n; ++i)
            for(int j = 2; j <= m; ++j)
                f[i][j] = a[i][j] + max(f[i-1][j], f[i][j-1]);
        
        g[n][m] = a[n][m];
        for(int i = n-1; i >= 1; --i)
            g[i][m] = g[i+1][m] + a[i][m];
        for(int i = m-1; i >= 1; --i)
            g[n][i] = g[n][i+1] + a[n][i];
        for(int i = n-1; i >= 1; --i)
            for(int j = m-1; j >= 1; --j)
                g[i][j] = a[i][j] + max(g[i+1][j], g[i][j+1]);
        
        int ans = f[n][m];
        //cout << ans<<endl;
        for(int i = 1; i <= n; ++i) {
            for(int j = 1; j <= m; ++j) {
                if(j<=m-1&&i>=2)
                    ans = max(ans, f[i][j] + g[i][j+1] + a[i-1][j+1]);
                if(i<=n-1&&j>=2)
                    ans = max(ans, f[i][j] + g[i+1][j] + a[i+1][j-1]);
                if(j<=m-2&&i>=2)
                    ans = max(ans, f[i][j] + g[i-1][j+2] + a[i][j+1] + a[i-1][j+1]);
                if(i<=n-2&&j>=2)
                    ans = max(ans, f[i][j] + g[i+2][j-1] + a[i+1][j] + a[i+1][j-1]);
            }
        }
        printf("%d\n", ans);
    }
    return 0;
}

```
## G. Boring Problem

## H. 课上例题和课后习题
矩阵快速幂，数学渣渣推不出系数。

## I. 完美主义人工智能AlphaOneDoubleC
